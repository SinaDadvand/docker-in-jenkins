// Comprehensive Jenkins Pipeline for Docker Integration
// This pipeline demonstrates all aspects of Docker integration with Jenkins

pipeline {
    // Agent configuration - where the pipeline runs
    agent any
    
    // Environment variables available throughout the pipeline
    environment {
        // Application configuration
        APP_NAME = 'jenkins-docker-demo'
        APP_VERSION = '1.0.0'
        
        // Docker configuration
        DOCKER_REGISTRY = 'docker.io'  // Change to your registry
        DOCKER_REPOSITORY = 'your-username'  // Change to your Docker Hub username
        IMAGE_NAME = "${DOCKER_REPOSITORY}/${APP_NAME}"
        
        // Build configuration
        BUILD_TIMESTAMP = sh(
            script: 'date +%Y%m%d-%H%M%S',
            returnStdout: true
        ).trim()
        
        // Dynamic image tags
        IMAGE_TAG = "${APP_VERSION}-${BUILD_NUMBER}"
        IMAGE_TAG_LATEST = 'latest'
        IMAGE_TAG_BRANCH = "${BRANCH_NAME}-${BUILD_NUMBER}"
        
        // Test configuration
        TEST_PORT = '3001'
        TEST_CONTAINER_NAME = "${APP_NAME}-test-${BUILD_NUMBER}"
        
        // Quality gates
        SECURITY_SCAN_ENABLED = 'true'
        PERFORMANCE_TEST_ENABLED = 'true'
    }
    
    // Pipeline options and configurations
    options {
        // Add timestamps to all console output
        timestamps()
        
        // Set overall pipeline timeout
        timeout(time: 45, unit: 'MINUTES')
        
        // Keep only last 20 builds to save space
        buildDiscarder(logRotator(
            numToKeepStr: '20',
            daysToKeepStr: '30',
            artifactNumToKeepStr: '10'
        ))
        
        // Prevent concurrent builds of the same job
        disableConcurrentBuilds()
        
        // Skip default checkout (we'll do it manually for better control)
        skipDefaultCheckout(false)
        
        // Colorize console output
        //ansiColor('xterm')
    }
    
    // Build parameters (can be set when triggering build manually)
    parameters {
        choice(
            name: 'DEPLOY_ENVIRONMENT',
            choices: ['dev', 'staging', 'production'],
            description: 'Target deployment environment'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip running tests (not recommended for production)'
        )
        booleanParam(
            name: 'FORCE_REBUILD',
            defaultValue: false,
            description: 'Force rebuild even if no changes detected'
        )
        string(
            name: 'CUSTOM_TAG',
            defaultValue: '',
            description: 'Custom Docker tag (optional)'
        )
    }
    
    // Build triggers
    triggers {
        // Poll SCM every 5 minutes for changes
        pollSCM('H/5 * * * *')
        
        // Build daily at 2 AM for nightly builds
        cron('H 2 * * *')
    }
    
    // Main pipeline stages
    stages {
        
        // Stage 1: Environment Setup and Validation
        stage('üîß Setup & Validation') {
            steps {
                dir('nodejs-docker-app') {
                    script {
                        echo "üöÄ Starting Jenkins Docker Integration Pipeline"
                        echo "üìã Build Information:"
                        echo "   Job Name: ${env.JOB_NAME}"
                        echo "   Build Number: ${env.BUILD_NUMBER}"
                        echo "   Build URL: ${env.BUILD_URL}"
                        echo "   Workspace: ${env.WORKSPACE}"
                        echo "   Node Name: ${env.NODE_NAME}"
                        echo "   Branch: ${env.BRANCH_NAME ?: 'main'}"
                        echo "   Commit: ${env.GIT_COMMIT ?: 'unknown'}"
                        
                        echo "üê≥ Docker Configuration:"
                        echo "   Registry: ${DOCKER_REGISTRY}"
                        echo "   Repository: ${DOCKER_REPOSITORY}"
                        echo "   Image Name: ${IMAGE_NAME}"
                        echo "   Primary Tag: ${IMAGE_TAG}"
                        echo "   Build Timestamp: ${BUILD_TIMESTAMP}"
                        
                        echo "‚öôÔ∏è Build Parameters:"
                        echo "   Deploy Environment: ${params.DEPLOY_ENVIRONMENT}"
                        echo "   Skip Tests: ${params.SKIP_TESTS}"
                        echo "   Force Rebuild: ${params.FORCE_REBUILD}"
                        echo "   Custom Tag: ${params.CUSTOM_TAG ?: 'none'}"
                    }
                    
                    // Validate Docker is available
                    sh '''
                        echo "üîç Validating Docker environment..."
                        
                        # Check Docker is running
                        if ! docker info > /dev/null 2>&1; then
                            echo "‚ùå Docker is not running or not accessible"
                            exit 1
                        fi
                        echo "‚úÖ Docker is available"
                        
                        # Display Docker version information
                        echo "üìä Docker Environment:"
                        docker version --format 'Client Version: {{.Client.Version}}'
                        docker version --format 'Server Version: {{.Server.Version}}'
                        
                        # Check available disk space
                        echo "üíæ Disk Space:"
                        df -h $WORKSPACE
                        
                        # Display Docker system information
                        echo "üê≥ Docker System:"
                        docker system df
                    '''
                    
                    // Validate required files exist
                    sh '''
                        echo "üìÅ Validating project structure..."
                        
                        # Check for required files
                        required_files="package.json Dockerfile src/server.js"
                        for file in $required_files; do
                            if [ ! -f "$file" ]; then
                                echo "‚ùå Required file missing: $file"
                                exit 1
                            fi
                            echo "‚úÖ Found: $file"
                        done
                        
                        # List project structure
                        echo "üìÇ Project Structure:"
                        find . -type f -name "*.json" -o -name "*.js" -o -name "Dockerfile*" -o -name "*.md" | head -20
                    '''
                }
            }
        }
        
        // Stage 2: Source Code Analysis and Quality Gates
        stage('üìù Code Analysis') {
            parallel {
                // Code quality analysis
                stage('Code Quality') {
                    tools {
                        nodejs 'NodeJS-18' // Name configured in Jenkins
                    }
                    steps {
                        echo "üîç Running code quality analysis..."
                        sh '''
                            echo "Node.js version: $(node --version)"
                            echo "npm version: $(npm --version)"
                            
                            echo "Installing dependencies for analysis..."
                            npm ci --only=dev || npm install
                            
                            echo "Running ESLint (if configured)..."
                            npm run lint || echo "‚ö†Ô∏è Linting skipped - no lint script configured"
                        '''
                    }
                }
                
                // Security scanning
                stage('Security Scan') {
                    when {
                        expression { env.SECURITY_SCAN_ENABLED == 'true' }
                    }
                    steps {
                        echo "üîí Running security analysis..."
                        sh '''
                            echo "Scanning for vulnerable dependencies..."
                            npm audit --audit-level=high || echo "‚ö†Ô∏è Security issues found - check npm audit output"
                            
                            echo "Checking for secrets in code..."
                            # Add secret scanning tools here (like git-secrets, truffleHog)
                            echo "‚úÖ Security scan completed"
                        '''
                    }
                }
                
                // Dependency analysis
                stage('Dependencies') {
                    steps {
                        echo "üì¶ Analyzing dependencies..."
                        sh '''
                            echo "Checking package.json validity..."
                            node -e "JSON.parse(require('fs').readFileSync('package.json', 'utf8'))"
                            echo "‚úÖ package.json is valid"
                            
                            echo "Checking for outdated packages..."
                            npm outdated || echo "‚ÑπÔ∏è Some packages have newer versions available"
                            
                            echo "Generating dependency tree..."
                            npm list --depth=1 || echo "‚ö†Ô∏è Some dependency issues found"
                        '''
                    }
                }
            }
        }
        
        // Stage 3: Unit and Integration Testing
        stage('üß™ Testing') {
            when {
                expression { !params.SKIP_TESTS }
            }
            parallel {
                // Unit tests
                stage('Unit Tests') {
                    steps {
                        echo "üß™ Running unit tests..."
                        sh '''
                            echo "Installing test dependencies..."
                            npm ci
                            
                            echo "Running unit test suite..."
                            npm test -- --coverage --watchAll=false --testResultsProcessor=jest-junit
                            
                            echo "‚úÖ Unit tests completed"
                        '''
                    }
                    post {
                        always {
                            // Publish test results (if available)
                            script {
                                if (fileExists('junit.xml')) {
                                    publishTestResults testResultsPattern: 'junit.xml'
                                }
                                if (fileExists('coverage')) {
                                    publishHTML([
                                        allowMissing: false,
                                        alwaysLinkToLastBuild: true,
                                        keepAll: true,
                                        reportDir: 'coverage/lcov-report',
                                        reportFiles: 'index.html',
                                        reportName: 'Coverage Report'
                                    ])
                                }
                            }
                        }
                    }
                }
                
                // Integration tests in Docker
                stage('Integration Tests') {
                    steps {
                        echo "üîó Running integration tests in Docker..."
                        sh '''
                            echo "Building test image..."
                            docker build -f docker/Dockerfile.test -t ${IMAGE_NAME}:test .
                            
                            echo "Running integration tests in container..."
                            docker run --rm \
                                --name ${TEST_CONTAINER_NAME}-integration \
                                -e NODE_ENV=test \
                                -e CI=true \
                                ${IMAGE_NAME}:test
                            
                            echo "‚úÖ Integration tests completed"
                        '''
                    }
                }
                
                // API tests
                stage('API Tests') {
                    steps {
                        echo "üåê Running API tests..."
                        sh '''
                            echo "Starting application for API testing..."
                            
                            # Build and start application container
                            docker build -t ${IMAGE_NAME}:api-test .
                            CONTAINER_ID=$(docker run -d -p ${TEST_PORT}:3000 \
                                --name ${TEST_CONTAINER_NAME}-api \
                                -e NODE_ENV=test \
                                ${IMAGE_NAME}:api-test)
                            
                            # Wait for application to start
                            echo "Waiting for application to start..."
                            sleep 10
                            
                            # Run API tests
                            echo "Testing API endpoints..."
                            
                            # Test health endpoint
                            if curl -f http://localhost:${TEST_PORT}/health; then
                                echo "‚úÖ Health endpoint test passed"
                            else
                                echo "‚ùå Health endpoint test failed"
                                docker logs ${CONTAINER_ID}
                                docker stop ${CONTAINER_ID}
                                docker rm ${CONTAINER_ID}
                                exit 1
                            fi
                            
                            # Test main endpoint
                            if curl -f http://localhost:${TEST_PORT}/; then
                                echo "‚úÖ Main endpoint test passed"
                            else
                                echo "‚ùå Main endpoint test failed"
                                docker logs ${CONTAINER_ID}
                                docker stop ${CONTAINER_ID}
                                docker rm ${CONTAINER_ID}
                                exit 1
                            fi
                            
                            # Test metrics endpoint
                            if curl -f http://localhost:${TEST_PORT}/metrics; then
                                echo "‚úÖ Metrics endpoint test passed"
                            else
                                echo "‚ö†Ô∏è Metrics endpoint test failed (non-critical)"
                            fi
                            
                            # Cleanup
                            docker stop ${CONTAINER_ID}
                            docker rm ${CONTAINER_ID}
                            
                            echo "‚úÖ API tests completed successfully"
                        '''
                    }
                }
            }
        }
        
        // Stage 4: Docker Image Building
        stage('üê≥ Docker Build') {
            parallel {
                // Production image
                stage('Production Image') {
                    steps {
                        echo "üèóÔ∏è Building production Docker image..."
                        script {
                            // Use Docker Pipeline plugin for better integration
                            def dockerfile = 'Dockerfile'
                            def buildArgs = [
                                'NODE_ENV=production',
                                "APP_VERSION=${APP_VERSION}",
                                "BUILD_NUMBER=${BUILD_NUMBER}",
                                "BUILD_TIMESTAMP=${BUILD_TIMESTAMP}"
                            ]
                            
                            // Build the image
                            def image = docker.build(
                                "${IMAGE_NAME}:${IMAGE_TAG}",
                                "--build-arg ${buildArgs.join(' --build-arg ')} -f ${dockerfile} ."
                            )
                            
                            // Tag with additional tags
                            image.tag("${IMAGE_TAG_LATEST}")
                            image.tag("${IMAGE_TAG_BRANCH}")
                            
                            if (params.CUSTOM_TAG) {
                                image.tag("${params.CUSTOM_TAG}")
                            }
                            
                            // Store image for later use
                            env.DOCKER_IMAGE_ID = image.id
                            
                            echo "‚úÖ Production image built successfully"
                            echo "üè∑Ô∏è Image ID: ${image.id}"
                            echo "üè∑Ô∏è Tags: ${IMAGE_TAG}, ${IMAGE_TAG_LATEST}, ${IMAGE_TAG_BRANCH}"
                        }
                    }
                }
                
                // Development image (optional)
                stage('Development Image') {
                    when {
                        anyOf {
                            branch 'develop'
                            expression { params.DEPLOY_ENVIRONMENT == 'dev' }
                        }
                    }
                    steps {
                        echo "üõ†Ô∏è Building development Docker image..."
                        sh '''
                            docker build \
                                -f docker/Dockerfile.dev \
                                -t ${IMAGE_NAME}:dev-${BUILD_NUMBER} \
                                -t ${IMAGE_NAME}:dev-latest \
                                --build-arg NODE_ENV=development \
                                .
                            
                            echo "‚úÖ Development image built successfully"
                        '''
                    }
                }
            }
        }
        
        // Stage 5: Image Security and Quality Scanning
        stage('üîí Security & Quality') {
            parallel {
                // Image security scanning
                stage('Image Security Scan') {
                    when {
                        expression { env.SECURITY_SCAN_ENABLED == 'true' }
                    }
                    steps {
                        echo "üîç Scanning Docker image for security vulnerabilities..."
                        sh '''
                            echo "Running Trivy security scan (if available)..."
                            if command -v trivy >/dev/null 2>&1; then
                                echo "Running Trivy scan..."
                                trivy image --exit-code 0 --severity HIGH,CRITICAL \
                                    --format table ${IMAGE_NAME}:${IMAGE_TAG}
                                
                                # Generate JSON report
                                trivy image --exit-code 0 --format json \
                                    --output trivy-report.json ${IMAGE_NAME}:${IMAGE_TAG}
                                
                                echo "‚úÖ Security scan completed"
                            else
                                echo "‚ö†Ô∏è Trivy not available - install for security scanning"
                                echo "Alternative: Manual security review required"
                            fi
                            
                            echo "Checking image for best practices..."
                            docker run --rm -i hadolint/hadolint < Dockerfile || echo "‚ö†Ô∏è Dockerfile linting issues found"
                        '''
                    }
                    post {
                        always {
                            script {
                                if (fileExists('trivy-report.json')) {
                                    archiveArtifacts artifacts: 'trivy-report.json', fingerprint: true
                                }
                            }
                        }
                    }
                }
                
                // Image optimization analysis
                stage('Image Analysis') {
                    steps {
                        echo "üìä Analyzing Docker image..."
                        sh '''
                            echo "Image size analysis..."
                            docker images ${IMAGE_NAME}:${IMAGE_TAG} --format "table {{.Repository}}:{{.Tag}}\\t{{.Size}}"
                            
                            echo "Image layer analysis..."
                            docker history ${IMAGE_NAME}:${IMAGE_TAG} --no-trunc
                            
                            echo "Image inspection..."
                            docker inspect ${IMAGE_NAME}:${IMAGE_TAG} | jq '.[0] | {
                                Created: .Created,
                                Size: .Size,
                                Architecture: .Architecture,
                                Config: {
                                    Env: .Config.Env,
                                    ExposedPorts: .Config.ExposedPorts,
                                    Healthcheck: .Config.Healthcheck
                                }
                            }' || docker inspect ${IMAGE_NAME}:${IMAGE_TAG}
                            
                            echo "‚úÖ Image analysis completed"
                        '''
                    }
                }
                
                // Performance testing
                stage('Performance Test') {
                    when {
                        expression { env.PERFORMANCE_TEST_ENABLED == 'true' }
                    }
                    steps {
                        echo "‚ö° Running performance tests..."
                        sh '''
                            echo "Starting application for performance testing..."
                            
                            # Start container for performance testing
                            PERF_CONTAINER_ID=$(docker run -d -p 3002:3000 \
                                --name ${TEST_CONTAINER_NAME}-perf \
                                --memory="256m" \
                                --cpus="0.5" \
                                ${IMAGE_NAME}:${IMAGE_TAG})
                            
                            # Wait for startup
                            sleep 15
                            
                            echo "Running basic performance tests..."
                            
                            # Test response time
                            for i in {1..5}; do
                                echo "Test $i:"
                                time curl -s http://localhost:3002/ > /dev/null
                            done
                            
                            # Test under load (basic)
                            echo "Running basic load test..."
                            for i in {1..20}; do
                                curl -s http://localhost:3002/health > /dev/null &
                            done
                            wait
                            
                            # Check container stats
                            echo "Container resource usage:"
                            docker stats ${PERF_CONTAINER_ID} --no-stream
                            
                            # Cleanup
                            docker stop ${PERF_CONTAINER_ID}
                            docker rm ${PERF_CONTAINER_ID}
                            
                            echo "‚úÖ Performance tests completed"
                        '''
                    }
                }
            }
        }
        
        // Stage 6: Registry Operations
        stage('üì§ Registry Operations') {
            when {
                anyOf {
                    branch 'main'
                    branch 'master'
                    branch 'develop'
                    expression { params.DEPLOY_ENVIRONMENT == 'production' }
                }
            }
            steps {
                echo "üì§ Pushing images to registry..."
                script {
                    // Push to registry using Docker Pipeline plugin
                    docker.withRegistry("https://${DOCKER_REGISTRY}", 'docker-hub-credentials') {
                        def image = docker.image("${IMAGE_NAME}:${IMAGE_TAG}")
                        
                        // Push all tags
                        image.push("${IMAGE_TAG}")
                        image.push("${IMAGE_TAG_LATEST}")
                        
                        if (env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'master') {
                            image.push("stable")
                        }
                        
                        if (params.CUSTOM_TAG) {
                            image.push("${params.CUSTOM_TAG}")
                        }
                        
                        echo "‚úÖ Images pushed successfully to ${DOCKER_REGISTRY}"
                        echo "üè∑Ô∏è Available tags: ${IMAGE_TAG}, ${IMAGE_TAG_LATEST}, stable"
                    }
                }
                
                // Generate deployment manifests
                sh '''
                    echo "üìã Generating deployment manifests..."
                    
                    # Create deployment directory
                    mkdir -p deployment-manifests
                    
                    # Generate Docker run command
                    cat > deployment-manifests/docker-run.sh << EOF
#!/bin/bash
# Docker run command for ${IMAGE_NAME}:${IMAGE_TAG}
docker run -d \\
    --name ${APP_NAME}-${params.DEPLOY_ENVIRONMENT} \\
    --restart unless-stopped \\
    -p 3000:3000 \\
    -e NODE_ENV=${params.DEPLOY_ENVIRONMENT} \\
    -e APP_VERSION=${APP_VERSION} \\
    -e BUILD_NUMBER=${BUILD_NUMBER} \\
    ${IMAGE_NAME}:${IMAGE_TAG}
EOF
                    chmod +x deployment-manifests/docker-run.sh
                    
                    # Generate docker-compose deployment
                    cat > deployment-manifests/docker-compose.yml << EOF
version: '3.8'
services:
  app:
    image: ${IMAGE_NAME}:${IMAGE_TAG}
    container_name: ${APP_NAME}-${params.DEPLOY_ENVIRONMENT}
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=${params.DEPLOY_ENVIRONMENT}
      - APP_VERSION=${APP_VERSION}
      - BUILD_NUMBER=${BUILD_NUMBER}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
EOF
                    
                    echo "‚úÖ Deployment manifests generated"
                '''
            }
        }
        
        // Stage 7: Deployment (Environment-specific)
        stage('üöÄ Deployment') {
            parallel {
                // Development deployment
                stage('Deploy to Dev') {
                    when {
                        expression { params.DEPLOY_ENVIRONMENT == 'dev' }
                    }
                    steps {
                        echo "üöÄ Deploying to development environment..."
                        sh '''
                            echo "Stopping existing development container..."
                            docker stop ${APP_NAME}-dev || true
                            docker rm ${APP_NAME}-dev || true
                            
                            echo "Starting new development container..."
                            docker run -d \\
                                --name ${APP_NAME}-dev \\
                                --restart unless-stopped \\
                                -p 3000:3000 \\
                                -e NODE_ENV=development \\
                                -e APP_VERSION=${APP_VERSION} \\
                                -e BUILD_NUMBER=${BUILD_NUMBER} \\
                                ${IMAGE_NAME}:${IMAGE_TAG}
                            
                            echo "Waiting for application to start..."
                            sleep 10
                            
                            echo "Verifying deployment..."
                            if curl -f http://localhost:3000/health; then
                                echo "‚úÖ Development deployment successful"
                                echo "üåê Application URL: http://localhost:3000"
                            else
                                echo "‚ùå Development deployment failed"
                                docker logs ${APP_NAME}-dev
                                exit 1
                            fi
                        '''
                    }
                }
                
                // Staging deployment
                stage('Deploy to Staging') {
                    when {
                        expression { params.DEPLOY_ENVIRONMENT == 'staging' }
                    }
                    steps {
                        echo "üöÄ Deploying to staging environment..."
                        sh '''
                            echo "Deploying to staging with docker-compose..."
                            
                            # Use generated docker-compose file
                            cd deployment-manifests
                            
                            # Update environment for staging
                            sed -i 's/NODE_ENV=.*/NODE_ENV=staging/' docker-compose.yml
                            sed -i 's/container_name: .*/container_name: ${APP_NAME}-staging/' docker-compose.yml
                            sed -i 's/"3000:3000"/"3001:3000"/' docker-compose.yml
                            
                            # Deploy
                            docker-compose -p ${APP_NAME}-staging up -d
                            
                            echo "Waiting for staging deployment..."
                            sleep 15
                            
                            echo "Verifying staging deployment..."
                            if curl -f http://localhost:3001/health; then
                                echo "‚úÖ Staging deployment successful"
                                echo "üåê Staging URL: http://localhost:3001"
                            else
                                echo "‚ùå Staging deployment failed"
                                docker-compose -p ${APP_NAME}-staging logs
                                exit 1
                            fi
                        '''
                    }
                }
                
                // Production deployment (manual approval required)
                stage('Deploy to Production') {
                    when {
                        expression { params.DEPLOY_ENVIRONMENT == 'production' }
                    }
                    input {
                        message "Deploy to production?"
                        ok "Deploy"
                        submitter "admin,devops-team"
                        parameters {
                            string(name: 'APPROVER', description: 'Who is approving this deployment?')
                        }
                    }
                    steps {
                        echo "üöÄ Deploying to production environment..."
                        echo "üë§ Approved by: ${APPROVER}"
                        sh '''
                            echo "Production deployment simulation..."
                            echo "In real scenarios, this would:"
                            echo "1. Deploy to production Kubernetes cluster"
                            echo "2. Update load balancer configuration"  
                            echo "3. Run smoke tests"
                            echo "4. Update monitoring dashboards"
                            echo "5. Send deployment notifications"
                            
                            echo "‚úÖ Production deployment completed"
                            echo "üè∑Ô∏è Deployed image: ${IMAGE_NAME}:${IMAGE_TAG}"
                            echo "üë§ Approved by: ${APPROVER}"
                        '''
                    }
                }
            }
        }
    }
    
    // Post-build actions
    post {
        // Always run regardless of build result
        always {
            echo "üßπ Running cleanup and archival tasks..."
            
            script {
                // Archive build artifacts
                if (fileExists('build-metadata.json')) {
                    archiveArtifacts artifacts: 'build-metadata.json', fingerprint: true
                }
                if (fileExists('deployment-manifests/')) {
                    archiveArtifacts artifacts: 'deployment-manifests/**', fingerprint: true
                }
                if (fileExists('test-results/')) {
                    archiveArtifacts artifacts: 'test-results/**', fingerprint: true
                }
                
                // Generate build summary
                def buildSummary = """
üöÄ BUILD SUMMARY
================
üìã Job: ${env.JOB_NAME}
üî¢ Build: #${env.BUILD_NUMBER}
üè∑Ô∏è Version: ${env.APP_VERSION}
üê≥ Image: ${env.IMAGE_NAME}:${env.IMAGE_TAG}
‚è±Ô∏è Duration: ${currentBuild.durationString}
üåø Branch: ${env.BRANCH_NAME ?: 'main'}
üéØ Environment: ${params.DEPLOY_ENVIRONMENT}
üë§ Started by: ${env.BUILD_USER ?: 'System'}
"""
                echo buildSummary
                
                // Save build summary to file
                writeFile file: 'build-summary.txt', text: buildSummary
                archiveArtifacts artifacts: 'build-summary.txt', fingerprint: true
            }
            
            // Clean up test containers
            sh '''
                echo "üßπ Cleaning up test containers..."
                docker ps -a --filter "name=${TEST_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f
                
                echo "üßπ Cleaning up unused Docker resources..."
                docker image prune -f --filter "label=build.number!=${BUILD_NUMBER}"
                docker system prune -f --volumes
            '''
            
            // Record build metrics
            script {
                def buildMetrics = [
                    build_number: env.BUILD_NUMBER,
                    duration_ms: currentBuild.duration,
                    result: currentBuild.result ?: 'SUCCESS',
                    image_tag: env.IMAGE_TAG,
                    deploy_env: params.DEPLOY_ENVIRONMENT,
                    timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'")
                ]
                
                writeJSON file: 'build-metrics.json', json: buildMetrics
                archiveArtifacts artifacts: 'build-metrics.json', fingerprint: true
            }
        }
        
        // Success-specific actions
        success {
            echo "‚úÖ Pipeline completed successfully!"
            
            script {
                def successMessage = """
üéâ BUILD SUCCESS!
=================
‚úÖ All stages completed successfully
üê≥ Docker image ready: ${env.IMAGE_NAME}:${env.IMAGE_TAG}
üöÄ Deployed to: ${params.DEPLOY_ENVIRONMENT}
‚è±Ô∏è Build time: ${currentBuild.durationString}
üîó Build URL: ${env.BUILD_URL}

üìã Next Steps:
‚Ä¢ Verify deployment in ${params.DEPLOY_ENVIRONMENT} environment
‚Ä¢ Monitor application performance
‚Ä¢ Run additional manual tests if needed
"""
                echo successMessage
                
                // In real scenarios, send notifications here:
                // - Slack notification
                // - Email to stakeholders
                // - Update deployment dashboard
                // - Trigger downstream jobs
            }
        }
        
        // Failure-specific actions
        failure {
            echo "‚ùå Pipeline failed!"
            
            script {
                def failureMessage = """
üí• BUILD FAILED!
================
‚ùå Pipeline failed at stage: ${env.STAGE_NAME ?: 'Unknown'}
üî¢ Build: #${env.BUILD_NUMBER}
‚è±Ô∏è Duration: ${currentBuild.durationString}
üîó Build URL: ${env.BUILD_URL}

üõ†Ô∏è Troubleshooting:
‚Ä¢ Check console output for detailed error messages
‚Ä¢ Review failed stage logs
‚Ä¢ Verify Docker environment and permissions
‚Ä¢ Check network connectivity to registries
‚Ä¢ Validate Dockerfile and build scripts

üìû Contact DevOps team if issue persists
"""
                echo failureMessage
                
                // Collect failure diagnostics
                sh '''
                    echo "Collecting failure diagnostics..."
                    docker system df > docker-diagnostics.txt
                    docker images --format "table {{.Repository}}:{{.Tag}}\\t{{.Size}}\\t{{.CreatedAt}}" >> docker-diagnostics.txt
                    docker ps -a >> docker-diagnostics.txt
                '''
                
                archiveArtifacts artifacts: 'docker-diagnostics.txt', allowEmptyArchive: true
            }
        }
        
        // Unstable build actions (tests failed but build succeeded)
        unstable {
            echo "‚ö†Ô∏è Pipeline completed but is unstable (test failures detected)"
            
            script {
                echo """
‚ö†Ô∏è UNSTABLE BUILD
==================
üß™ Some tests failed but build completed
üê≥ Docker image was created: ${env.IMAGE_NAME}:${env.IMAGE_TAG}
‚ö†Ô∏è Deployment may be risky - review test results

üîç Review:
‚Ä¢ Check test reports for failure details
‚Ä¢ Determine if failures are critical
‚Ä¢ Consider fixing tests before deployment
"""
            }
        }
        
        // Build result changed from previous build
        changed {
            echo "üîÑ Build result changed from previous build"
            
            script {
                def currentResult = currentBuild.result ?: 'SUCCESS'
                def previousResult = currentBuild.previousBuild?.result ?: 'UNKNOWN'
                
                echo "Previous result: ${previousResult} ‚Üí Current result: ${currentResult}"
                
                if (currentResult == 'SUCCESS' && previousResult == 'FAILURE') {
                    echo "üéâ Build is back to normal!"
                } else if (currentResult == 'FAILURE' && previousResult == 'SUCCESS') {
                    echo "üö® Build has started failing!"
                }
            }
        }
    }
}